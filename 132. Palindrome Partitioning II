https://leetcode.com/problems/palindrome-partitioning-ii/
class Solution { 
       public static int minCut (String input) {
        if (input == null || input.length() <= 1) {
            return 0;
        }
       //DP 
       
        char[] s = input.toCharArray();
        int[] dp = new int[s.length+1];
       
        dp[0] = 0;  // end at index 0, but not including index 0, so no letter
        dp[1] = 0;  // end at index 1, but not including index 1, so 1 letter 
        for (int i = 2; i < dp.length; i++ ) { // i represents the # of letters in the input string
            //超级易错点： 这里 i 是你新建的 dp array 里面的index, 所以 i 是小于 dp.length, 而不是 s.length
            int minCuts = Integer.MAX_VALUE;
            for (int j = 0; j < i; j++) {// j represents the possible cuts for a given number of letters string
                if (isPalindrome(s, j, i-1)){ //dp[j] can be checked from the table
                     if (j==0) {
                         minCuts = 0;
                         break;
                     }
                    
                    else {
                    minCuts = Math.min(minCuts, dp[j]+1);
                    }
                }            
            }
            dp[i] = minCuts;
        }
        return dp[s.length];
       }
           
    
    private static boolean isPalindrome(char[] array, int i, int j) {
        while (i < j) {
            if (array[i] != array[j]) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
    
    
