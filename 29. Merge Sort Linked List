Given a singly-linked list, where each node contains an integer value, sort it in ascending order. The merge sort algorithm should be used to solve this problem.

Examples

null, is sorted to null
1 -> null, is sorted to 1 -> null
1 -> 2 -> 3 -> null, is sorted to 1 -> 2 -> 3 -> null
4 -> 2 -> 6 -> -3 -> 5 -> null, is sorted to -3 -> 2 -> 4 -> 5 -> 6


/**
 * class ListNode {
 *   public int value;
 *   public ListNode next;
 *   public ListNode(int value) {
 *     this.value = value;
 *     next = null;
 *   }
 * }
 */
public class Solution {
  public ListNode mergeSort(ListNode head) {
    //corner case 
    if (head == null || head.next == null) {
      return head;
    }
    // split the list into two halves
    ListNode middle = findMiddle(head);
    ListNode middleNext = middle.next;
    middle.next = null; //断开middle和next的连接
    //sort each half
    ListNode left = mergeSort(head);
    ListNode right = mergeSort(middleNext);
    return merge(left, right); //combine two halves 
  }
  public ListNode findMiddle(ListNode head) {  //这个function的TC: O(n) , SC: O(1)
    if (head == null) {
      return head;
    }
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
      slow = slow.next; //出错代码： slow = head.next; 
      fast = fast.next.next;
    }
    return slow;
  }
  public ListNode merge (ListNode one, ListNode two){  //这个function的TC: O(m+n), SC: O(1)
    ListNode dummy = new ListNode(0); // 如何new 一个dummy node, 常忘点
    ListNode cur = dummy;
    while (one != null && two != null) {
      if (one.value <= two.value) {
          cur.next = one;
          one = one.next;
      }
      else {
        cur.next = two;
        two = two.next;
      }
      cur = cur.next;
    }
    if (one != null) {
      cur.next = one;
    }
    else {
      cur.next = two;
    }
    return dummy.next;
  }


}
