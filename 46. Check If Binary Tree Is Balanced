Check if a given binary tree is balanced. A balanced binary tree is one in which the depths of every node’s left and right subtree differ by at most 1.

Examples

        5

      /    \

    3        8

  /   \        \

1      4        11

is balanced binary tree,

        5

      /

    3

  /   \

1      4

is not balanced binary tree.

Corner Cases

What if the binary tree is null? Return true in this case.
How is the binary tree represented?

We use the level order traversal sequence with a special symbol "#" denoting the null node.

For Example:

The sequence [1, 2, 3, #, #, 4] represents the following binary tree:

    1

  /   \

 2     3

      /

    4

/**
 * public class TreeNode {
 *   public int key;
 *   public TreeNode left;
 *   public TreeNode right;
 *   public TreeNode(int key) {
 *     this.key = key;
 *   }
 * }
 */
public class Solution {
  public boolean isBalanced(TreeNode root) {
    //base case
    if (root == null) {
      return true;
    }
    //subproblem: isBalanced(root.left), isBalanced(root.right)
    //recursion rule: isBalanced(root.left)is false-> return false; if isBalanced(root.right) is false ==> return false
    //            right now, left and right subtree is balanced
    //            next, let us check the height diff: |leftHeight - rightHeight| > 1 -> return false 
    boolean left = isBalanced(root.left);
    boolean right = isBalanced(root.right);
    if (!left || !right) { // 等价于： left == false ||   right == false
      return false;
    }
    if (Math.abs(findHeight(root.left) - findHeight(root.right)) > 1) {
        return false;
    }
    return true;
  }
  public int findHeight (TreeNode root) {
    int height = 0;
    int leftHeight = 0;
    int rightHeight = 0;
    if (root == null) {
      return height;
    }
    leftHeight = findHeight(root.left);
    rightHeight = findHeight (root.right);
    height = Math.max(leftHeight,rightHeight) + 1; 
    return height; 
  }
}
//TC: 这套题的时间复杂度要考虑findHeight: 而findHeight 的时间复杂度是： O(n), 对于左子树的时间复杂度是O(n/2), 右子树的时间复杂度： O(n/2)
//                                       ==> 对于左子树的left subTree, 时间复杂度是O(1/2 * (n/2)), 左子树的right subTree时间复杂度： O(1/2 * (n/2))
//                                       ==> 对于右子树的left subTree, 时间复杂度是O(1/2 * (n/2)), 右子树的right subTree时间复杂度： O(1/2 * (n/2))
//                                       ==> 所以第二层的total tc: is n 
// so, we have total log2 n 层， 然后每层的时间复杂度是n, 所以 log2n * n => 这是最好的情况了，当tree 是balanced
                                        



//Solution 2 更优解
public class Solution {
  public int getHeightOrUnbalanced(TreeNode root) {
    int height = 0;
    //base case: null --> return 0 

    //subproblem: getHeightOrUnbalanced(root.left), getHeightOrUnbalance(root.right);
    // recursion rule: 1) if getHeightOrUnbalanced(root.left) == -1 || getHeightOrUnbalanced(root.right)==-1 : return -1
    //                 2) if |leftHeight - rightHeight| > 1, return -1
    //                 return Max(leftHeight, rightHeight) + 1
    if (root == null){
      return height;
    }
    int leftHeight = getHeightOrUnbalanced(root.left);
    int rightHeight = getHeightOrUnbalanced(root.right);
    if (leftHeight == -1 || rightHeight == -1) {
      return -1;
    }
    else if ( Math.abs(leftHeight - rightHeight) > 1) {
      return -1;
    }
    else {
      return Math.max(leftHeight, rightHeight) + 1;
    }
  }
  public boolean isBalanced(TreeNode root) {
    if (root == null) {
      return true;
    }
    if (getHeightOrUnbalanced(root) == -1) {
      return false;
    }
    else {
      return true;
    }
  }  
}

//TC: O(n) : so we only have one recursion now :) 
//SC: O(height) 


